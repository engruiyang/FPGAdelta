`timescale 1ns / 1ps
module audio_passthrough(
    input        clk,         // FPGA 主时钟 50 MHz
    input        rst_n,       // 异步复位（低有效）
    input        btn_n,       // 按键输入（低有效）

    // SPI型 ADC 接口
    output reg   ADC_CS,      // 片选（低有效）
    output reg   ADC_SCK,     // 串行时钟
    input        ADC_MISO,    // 串行数据输出
    output reg   ADC_RSTN,    // ADC复位输入

    // PWM 输出
    output reg   AUDIO_PWM,

    // LED 指示灯
    output reg [7:0] LED_ALL  // 8个LED
);

    // -----------------------------
    // 按键控制逻辑
    // -----------------------------
    wire enable = ~btn_n; // 按下为1，启动透传

    // -----------------------------
    // ADC 初始化状态机
    // -----------------------------
    reg [15:0] init_cnt;
    reg adc_ready;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            ADC_RSTN <= 0;
            ADC_CS <= 1;
            init_cnt <= 0;
            adc_ready <= 0;
        end else begin
            if(init_cnt < 16'd15_000) begin // 复位300us @ 50MHz
                ADC_RSTN <= 0;
                init_cnt <= init_cnt + 1;
            end else if(init_cnt < 16'd500_000) begin // 延时10ms
                ADC_RSTN <= 1;
                init_cnt <= init_cnt + 1;
            end else begin
                adc_ready <= 1;
                ADC_CS <= 0; // 拉低开始读数
            end
        end
    end

    // -----------------------------
    // SCK 分频生成（50 SCK 采样周期）
    // -----------------------------
    reg [7:0] sck_div;
    reg sck_int;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            sck_div <= 0;
            sck_int <= 0;
            ADC_SCK <= 0;
        end else if(adc_ready) begin
            sck_div <= sck_div + 1;
            if(sck_div >= 8'd50) begin
                sck_int <= ~sck_int;
                ADC_SCK <= ~ADC_SCK;
                sck_div <= 0;
            end
        end else begin
            sck_div <= 0;
            sck_int <= 0;
            ADC_SCK <= 0;
        end
    end

    // -----------------------------
    // 串转并 (Serial to Parallel)
    // -----------------------------
    reg [15:0] shift_reg;
    reg [4:0]  bit_cnt;
    reg [15:0] audio_sample;
    reg        pcm_ready;

    always @(posedge sck_int or negedge rst_n) begin
        if(!rst_n) begin
            bit_cnt <= 0;
            shift_reg <= 0;
            pcm_ready <= 0;
        end else if(adc_ready && !ADC_CS) begin
            shift_reg <= {shift_reg[14:0], ADC_MISO};
            bit_cnt <= bit_cnt + 1;
            pcm_ready <= 0;
            if(bit_cnt == 15) begin
                audio_sample <= {shift_reg[14:0], ADC_MISO};
                pcm_ready <= 1;
                bit_cnt <= 0;
            end
        end else begin
            bit_cnt <= 0;
            pcm_ready <= 0;
        end
    end

    // -----------------------------
    // 音频信号检测 LED2
    // -----------------------------
    reg [15:0] prev_sample;
    reg [15:0] diff;
    reg [23:0] led_timer;
    reg led2_flash;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            prev_sample <= 0;
            diff <= 0;
            led_timer <= 0;
            led2_flash <= 0;
        end else if(pcm_ready) begin
            diff <= (audio_sample > prev_sample) ? (audio_sample - prev_sample) : (prev_sample - audio_sample);
            prev_sample <= audio_sample;

            if(diff > 16'd2) begin
                led_timer <= 24'd12_000_000; // 保持约0.24s亮
                led2_flash <= 1;
            end
        end else if(led_timer > 0) begin
            led_timer <= led_timer - 1;
            if(led_timer == 0) led2_flash <= 0;
        end else begin
            led2_flash <= 0;
        end
    end

    // -----------------------------
    // PWM 输出与 LED 控制
    // -----------------------------
    reg [15:0] pwm_cnt;

    always @(posedge clk or negedge rst_n) begin
        if(!rst_n) begin
            pwm_cnt <= 0;
            AUDIO_PWM <= 0;
            LED_ALL <= 8'b0;
        end else begin
            pwm_cnt <= pwm_cnt + 1;

            // 音频PWM输出
            if(enable && pcm_ready)
                AUDIO_PWM <= (audio_sample > pwm_cnt);
            else
                AUDIO_PWM <= 0;

            // LED控制逻辑
            if(enable) begin
                LED_ALL[0] <= 1'b1;       // LED1: 启动指示
                LED_ALL[1] <= led2_flash; // LED2: 有信号闪烁
                LED_ALL[7:2] <= 6'b0;
            end else begin
                LED_ALL <= 8'b0;
            end
        end
    end

endmodule
