`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////////////////////////
// Top module: v1 (pure Verilog version, with voice-band FIR filter)
// Human voice band 300–3400 Hz, fs ≈ 50 kS/s
//////////////////////////////////////////////////////////////////////////////////

module v1(
    input  clk,
    input  MISO,
    input  sw0,
    output SCK,
    output CS,
    output clk_baud,
    output adc_rst_n,
    output [3:0] seg_sel,
    output [7:0] seg_led,
    output AudioPWM
    );

    wire clk_200M;
    reg [31:0] pll_rst_cnt = 0;
    always @(posedge clk)
        if (!pll_rst_cnt[15]) pll_rst_cnt <= pll_rst_cnt + 1'b1;

    assign adc_rst_n = pll_rst_cnt[15];

    PLL mypll(
        .refclk(clk),
        .reset(!pll_rst_cnt[15]),
        .clk0_out(clk_200M)
    );

    parameter DIVCLK_CNTMAX = 39;

    clock_division #(.DIVCLK_CNTMAX(DIVCLK_CNTMAX)) u_div_baud (
        .clk_in(clk_200M),
        .divclk(clk_baud)
    );

    reg [31:0] rst_cnt = 0;
    always @(posedge clk)
        if (!rst_cnt[20]) rst_cnt <= rst_cnt + 1'b1;

    // ADC SPI receive
    wire [15:0] data_out_raw;
    spi_rx u_spi (
        .clk_baud(clk_baud),
        .sck(SCK),
        .cs(CS),
        .miso(MISO),
        .rst_n(rst_cnt[20]),
        .data_out(data_out_raw)
    );

    // ====== Band-pass FIR filter (pure Verilog) ======
    wire signed [15:0] data_out_filt;
    bandpass_fir_31 u_bp (
        .clk(clk_baud),
        .rst_n(rst_cnt[20]),
        .din(data_out_raw),
        .dout(data_out_filt)
    );

    // ====== Display section (unchanged) ======
    parameter DIVCLK_CNTMAX_1ms = 24999;
    wire clk_1ms;
    clock_division #(.DIVCLK_CNTMAX(DIVCLK_CNTMAX_1ms)) u_div_1ms (
        .clk_in(clk),
        .divclk(clk_1ms)
    );

    Digitron4bits u_dig (
        .clk_1K(clk_1ms),
        .ina(data_out_filt[3:0]),
        .inb(data_out_filt[7:4]),
        .inc(data_out_filt[11:8]),
        .ind(data_out_filt[15:12]),
        .dot(3'b000),
        .seg_sel(seg_sel),
        .seg_led(seg_led)
    );

    // ====== PWM DAC (unchanged) ======
    reg [11:0] AudioPWM_cnt;
    always @(posedge clk_200M)
        if (AudioPWM_cnt == 12'd3999)
            AudioPWM_cnt <= 12'd0;
        else
            AudioPWM_cnt <= AudioPWM_cnt + 1'b1;

    wire rdclk = (AudioPWM_cnt <= 12'd1999) ? 1'b0 : 1'b1;

    wire [11:0] audiodata_out;
    fifo u_fifo (
        .rst(!rst_cnt[20]),
        .di(data_out_filt),
        .clkw(CS),
        .we(1'b1),
        .do(audiodata_out),
        .clkr(rdclk),
        .re(1'b1),
        .empty_flag(),
        .full_flag()
    );

    assign AudioPWM = (audiodata_out[11:0] < AudioPWM_cnt) ? 1'b0 : 1'b1;

endmodule

/************************************************************\
 **  Copyright (c) 2011-2022 Anlogic, Inc.
 **  All Right Reserved.\
\************************************************************/
/************************************************************\
 ** Log	:	This file is generated by Anlogic IP Generator.
 ** File	:	F:/BaiduNetdiskDownload/Anlogic/9.3 EG4S_SPIREADADC/al_ip/PLL.v
 ** Date	:	2024 02 20
 ** TD version	:	5.6.56362
\************************************************************/

///////////////////////////////////////////////////////////////////////////////
//	Input frequency:             50.000MHz
//	Clock multiplication factor: 4
//	Clock division factor:       1
//	Clock information:
//		Clock name	| Frequency 	| Phase shift
//		C0        	| 200.000000MHZ	| 0  DEG     
///////////////////////////////////////////////////////////////////////////////
`timescale 1 ns / 100 fs

module PLL (
  refclk,
  reset,
  clk0_out 
);

  input refclk;
  input reset;
  output clk0_out;

  wire clk0_buf;

  EG_LOGIC_BUFG bufg_feedback (
    .i(clk0_buf),
    .o(clk0_out) 
  );

  EG_PHY_PLL #(
    .DPHASE_SOURCE("DISABLE"),
    .DYNCFG("DISABLE"),
    .FIN("50.000"),
    .FEEDBK_MODE("NORMAL"),
    .FEEDBK_PATH("CLKC0_EXT"),
    .STDBY_ENABLE("DISABLE"),
    .PLLRST_ENA("ENABLE"),
    .SYNC_ENABLE("DISABLE"),
    .DERIVE_PLL_CLOCKS("DISABLE"),
    .GEN_BASIC_CLOCK("DISABLE"),
    .GMC_GAIN(4),
    .ICP_CURRENT(13),
    .KVCO(4),
    .LPF_CAPACITOR(1),
    .LPF_RESISTOR(4),
    .REFCLK_DIV(1),
    .FBCLK_DIV(4),
    .CLKC0_ENABLE("ENABLE"),
    .CLKC0_DIV(5),
    .CLKC0_CPHASE(4),
    .CLKC0_FPHASE(0) 
  ) pll_inst (
    .refclk(refclk),
    .reset(reset),
    .stdby(1'b0),
    .extlock(open),
    .load_reg(1'b0),
    .psclk(1'b0),
    .psdown(1'b0),
    .psstep(1'b0),
    .psclksel(3'b000),
    .psdone(open),
    .dclk(1'b0),
    .dcs(1'b0),
    .dwe(1'b0),
    .di(8'b00000000),
    .daddr(6'b000000),
    .do({open, open, open, open, open, open, open, open}),
    .fbclk(clk0_out),
    .clkc({open, open, open, open, clk0_buf}) 
  );

endmodule

`timescale 1ns / 1ps
module clock_division(clk_in,divclk);
    input clk_in;
    output divclk;
    parameter DIVCLK_CNTMAX = 24999; //时钟分频计数的最大值
    reg [31:0] cnt = 0;              
    reg divclk_reg = 0;
    always@(posedge clk_in) begin
        if(cnt == DIVCLK_CNTMAX) begin
            cnt <= 0;
            divclk_reg <= ~divclk_reg;
        end
        else
            cnt <= cnt + 1;
    end 
    assign divclk = divclk_reg;
endmodule

 module spi_rx(clk_baud,sck,cs,miso,rst_n,data_out);//接收器设计			    
input clk_baud;//SPI的SCK时钟
input miso,rst_n;
output sck;
output reg cs;
output reg [15:0] data_out;

reg [15:0] clk_baud_cnt=16'd0;
parameter  idle=3'd1,one=3'd2,two=3'd3,stop=3'd4;//状态机的4个状态
reg [2:0] present_state=idle;//状态机当前状态
reg [2:0] next_state=idle;//状态机下一个状态


always @ (posedge clk_baud)
	begin
		if(!rst_n)
			begin
				present_state <= stop;
			end
		else
			begin
				present_state <= next_state;
			end	
	end		

always @ (negedge clk_baud)//根据当前状态机的状态和判断条件, 决定状态机的下一个状态
begin
   	begin
		if(!rst_n)
			begin
				clk_baud_cnt <= 16'd00;
			end
		else
           begin
               clk_baud_cnt <= clk_baud_cnt + 1'b1;
   					if(clk_baud_cnt > 16'd0 && clk_baud_cnt <= 16'd30)//启动，等待ADC转换完成
						next_state <= idle;
					else if(clk_baud_cnt > 16'd30 && clk_baud_cnt <= 16'd46)//接收16位数据
						next_state <= one;
					else if(clk_baud_cnt > 16'd46 && clk_baud_cnt <= 16'd47)//保持
						next_state <= two;
					else if(clk_baud_cnt > 16'd47 && clk_baud_cnt <= 16'd48)//CS拉高
						next_state <= stop;
					else if(clk_baud_cnt == 16'd49)
						clk_baud_cnt <= 16'd00;	
           end
    end
 end	

always @ (posedge clk_baud)	//根据当前状态机的状态, 决定输出
begin
if(!rst_n)
	begin
	  cs <= 1'b1;
	end
else
	begin
		case(next_state)
		idle:	begin
					cs <= 1'b0;
				end				
		one:	begin//接收16位数据
					if(clk_baud_cnt == 16'd32) data_out[15] <= miso;
					else if(clk_baud_cnt == 16'd33) data_out[14] <= miso;
					else if(clk_baud_cnt == 16'd34) data_out[13] <= miso;
					else if(clk_baud_cnt == 16'd35) data_out[12] <= miso;
					else if(clk_baud_cnt == 16'd36) data_out[11] <= miso;
					else if(clk_baud_cnt == 16'd37) data_out[10] <= miso;
					else if(clk_baud_cnt == 16'd38) data_out[9] <= miso;
					else if(clk_baud_cnt == 16'd39) data_out[8] <= miso;
                    else if(clk_baud_cnt == 16'd40) data_out[7] <= miso;
					else if(clk_baud_cnt == 16'd41) data_out[6] <= miso;
					else if(clk_baud_cnt == 16'd42) data_out[5] <= miso;
					else if(clk_baud_cnt == 16'd43) data_out[4] <= miso;
					else if(clk_baud_cnt == 16'd44) data_out[3] <= miso;
					else if(clk_baud_cnt == 16'd45) data_out[2] <= miso;
					else if(clk_baud_cnt == 16'd46) data_out[1] <= miso;
                    else if(clk_baud_cnt == 16'd47) data_out[0] <= miso;
				end				
		two:	begin	//保持								
					cs <= 1'b0;
				end
		stop:	begin						//停止							
					begin
                       cs <= 1'b1;
 					end
           		end
		endcase
	end
end						

assign sck = (next_state == one)? clk_baud : 1'b0;						

endmodule

module Digitron4bits(clk_1K,ina,inb,inc,ind,dot,seg_sel,seg_led);
    input clk_1K;
    input [3:0] ina,inb,inc,ind;    
    input [2:0] dot;
    output [3:0] seg_sel;
    output [7:0] seg_led;

    //例化计数器模块
    wire [1:0] bit_disp;
    counter counter(
        .clk(clk_1K),
        .cnt(bit_disp)
    );

    //例化多路复用器模块
    wire [3:0] data_disp;    
	wire dot_ena;
    Mux Mux(
       	.sel(bit_disp),
        .ina(ina),
        .inb(inb),        
        .inc(inc),
        .ind(ind),          
        .dot(dot),        
        .dot_ena(dot_ena),
        .data_out(data_disp)
    );
    
    //例化数码管位选译码模块
    seg_sel_decoder seg_sel_decoder(
        .bit_disp(bit_disp),
        .seg_sel(seg_sel)
    );

    //例化数码管段码译码模块
    seg_led_decoder seg_led_decoder(
        .data_disp(data_disp),    
        .dot_ena(dot_ena),
        .seg_led(seg_led)
    );
    

endmodule

`timescale 1ns / 1ps
//////////////////////////////////////////////////////////////
// 31-tap FIR 带通滤波器 (Verilog-2001)
// 采样率约 50 kS/s，通带约 300–3400 Hz
//////////////////////////////////////////////////////////////

module bandpass_fir_31(
    input               clk,
    input               rst_n,
    input  signed [15:0] din,
    output reg signed [15:0] dout
    );

    // 延迟线寄存器
    reg signed [15:0] x[0:30];
    integer i;

    // 累加寄存器
    reg signed [47:0] acc;
    reg signed [31:0] tmp_sum;
    reg signed [15:0] coeff;

    // 取系数函数，用 case 替代数组参数
    function signed [15:0] get_coeff;
        input [4:0] idx;
        begin
            case (idx)
                0:  get_coeff = -23;
                1:  get_coeff = -54;
                2:  get_coeff = -109;
                3:  get_coeff = -197;
                4:  get_coeff = -309;
                5:  get_coeff = -412;
                6:  get_coeff = -452;
                7:  get_coeff = -366;
                8:  get_coeff = -97;
                9:  get_coeff = 382;
                10: get_coeff = 1055;
                11: get_coeff = 1858;
                12: get_coeff = 2682;
                13: get_coeff = 3400;
                14: get_coeff = 3889;
                15: get_coeff = 4063;
                default: get_coeff = 16'sd0;
            endcase
        end
    endfunction

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            for (i=0;i<31;i=i+1) x[i] <= 16'sd0;
            dout <= 16'sd0;
        end else begin
            // 移位寄存器
            for (i=30;i>0;i=i-1)
                x[i] <= x[i-1];
            x[0] <= din;

            // 对称系数卷积累加
            acc = 48'sd0;
            for (i=0;i<15;i=i+1) begin
                tmp_sum = x[i] + x[30-i];
                coeff = get_coeff(i);
                acc = acc + tmp_sum * coeff;
            end
            acc = acc + x[15] * get_coeff(15);

            // 缩放到 Q1.15
            if (acc > 48'sd1073741823)
                dout <= 16'sd32767;
            else if (acc < -48'sd1073741824)
                dout <= -16'sd32768;
            else
                dout <= acc[30:15];
        end
    end
endmodule
